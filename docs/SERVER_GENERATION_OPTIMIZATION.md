# Оптимизация серверной генерации консультаций САЛ

## Выполненные оптимизации

### 1. Улучшенный парсинг ответов от API

#### Проблема
- Неполная обработка формата Responses API для gpt-5-mini
- Отсутствие детального логирования при ошибках парсинга
- Нет обработки альтернативных форматов ответа

#### Решение
- ✅ Полная поддержка формата Responses API: `output/outputs` → `message` → `content` → `output_text` → `text`
- ✅ Детальное логирование на каждом этапе парсинга
- ✅ Обработка всех альтернативных форматов ответа
- ✅ Четкие сообщения об ошибках при неудачном парсинге

**Файл:** `lib/sal-generation.ts` (функция `callOpenAI`)

### 2. Валидация данных после генерации

#### Проблема
- Отсутствие проверки структуры сгенерированных данных
- Нет проверки соответствия схеме JSON Schema
- Риск сохранения некорректных данных

#### Решение
- ✅ Создан модуль `lib/consultation-validator.ts` с валидацией для всех типов консультаций
- ✅ Проверка обязательных полей
- ✅ Проверка длин массивов (strengths - 7, weaknesses - 7, resourceSignals - 10, и т.д.)
- ✅ Проверка структуры вложенных объектов (conflicts, practices, currentDiagnostics)
- ✅ Обнаружение смешивания weaknesses и resourceSignals
- ✅ Валидация выполняется после генерации, перед сохранением

**Файл:** `lib/consultation-validator.ts`

### 3. Улучшенное сохранение в Directus

#### Проблема
- Отсутствие retry логики при сохранении
- Нет проверки успешности сохранения
- Нет валидации входных данных перед сохранением

#### Решение
- ✅ Retry логика (до 3 попыток) для надежности сохранения
- ✅ Разделение обработки клиентских (4xx) и серверных (5xx) ошибок
- ✅ Валидация входных данных (profileId, codes, consultationResult)
- ✅ Проверка успешности сохранения через ответ API
- ✅ Детальное логирование всех попыток сохранения

**Файл:** `lib/sal-generation.ts` (функция `saveConsultationToProfile`)

### 4. Правильное формирование промптов

#### Проблема
- Базовый расчет требовал два отдельных user сообщения, но отправлялось одно

#### Решение
- ✅ Для базового расчета формируются два user сообщения (как в оригинальном n8n промпте)
- ✅ Функция `createBaseUserPrompts` возвращает массив из двух сообщений
- ✅ Функция `callOpenAI` поддерживает как строку, так и массив сообщений

**Файл:** `lib/sal-generation.ts` (функции `createBaseUserPrompts`, `callOpenAI`)

### 5. Улучшенная обработка ошибок

#### Проблема
- Недостаточно детальное логирование ошибок
- Нет различия между типами ошибок (таймаут, сетевой сбой, ошибка API)
- Отсутствие контекста при ошибках

#### Решение
- ✅ Детальное логирование всех ошибок с контекстом
- ✅ Разделение обработки разных типов ошибок
- ✅ Правильная retry логика (только для серверных ошибок и сетевых сбоев)
- ✅ Информативные сообщения об ошибках для пользователя

**Файл:** `lib/sal-generation.ts`, `app/api/calc-server/route.ts`

### 6. Оптимизация логирования

#### Проблема
- Недостаточно информации для отладки
- Нет логирования промежуточных этапов

#### Решение
- ✅ Логирование запросов к API (URL, модель, наличие схемы)
- ✅ Логирование ответов (формат, ключи, размер)
- ✅ Логирование этапов валидации
- ✅ Логирование попыток сохранения
- ✅ Структурированные логи с префиксами `[SAL-GENERATION]`, `[CALC-SERVER]`

## Структура валидации

### Базовый расчет
- ✅ opener (строка)
- ✅ personalitySummary (массив, ровно 3 элемента)
- ✅ strengths (массив, ровно 7 элементов)
- ✅ weaknesses (массив, ровно 7 элементов)
- ✅ happinessFormula (массив, 2-3 элемента)
- ✅ resourceSignals (массив, ровно 10 элементов)
- ✅ deficitSignals (массив, ровно 10 элементов)
- ✅ codesExplanation (массив, 3-5 элементов)
- ✅ conflicts (массив, ровно 5 объектов с title, description, manifestations, advice)
- ✅ practices (объект с 5 ресурсами, каждый по 3 практики)

### Целевой расчет
- ✅ warnings (массив)
- ✅ goalDecomposition (массив)
- ✅ resourcesForStages (массив)
- ✅ currentDiagnostics (объект с resourceStates, readiness, questions)
- ✅ plan123 (массив, ровно 3 этапа)
- ✅ progressMetrics (объект с earlySignals, midSignals, resultSignals)
- ✅ whatIf (объект с fatigue, overwhelm, relapse, pitfalls)
- ✅ objectionHandling (массив)
- ✅ finalStrategy (массив, ровно 3 абзаца)

### Партнерский расчет
- ✅ Все поля целевого расчета +
- ✅ compatibility (объект с complementary и conflicts)
- ✅ currentDiagnostics с firstParticipant, secondParticipant, conflictZones

## Обработка форматов ответа

### gpt-5-mini (Responses API)
1. `output/outputs` → массив → `message` → `content` → `output_text` → `text` → JSON
2. Прямой `output` объект
3. `output` как строка JSON
4. `text` поле

### Стандартный OpenAI
1. `choices[0].message.content` → JSON строка

### Fallback
- Логирование всех доступных ключей
- Выброс понятной ошибки с деталями

## Retry логика

### Генерация консультации
- **Максимум попыток:** 3
- **Повторяем:** только серверные ошибки (5xx) и сетевые сбои
- **Не повторяем:** клиентские ошибки (4xx), ошибки парсинга
- **Задержка:** экспоненциальная (1s, 2s, 3s)

### Сохранение в Directus
- **Максимум попыток:** 3
- **Повторяем:** только серверные ошибки (5xx) и сетевые сбои
- **Не повторяем:** клиентские ошибки (4xx)
- **Задержка:** экспоненциальная (1s, 2s, 3s)
- **Таймаут:** 30 секунд на запрос

## Проверка качества

### Перед сохранением
1. ✅ Валидация структуры данных
2. ✅ Проверка обязательных полей
3. ✅ Проверка длин массивов
4. ✅ Проверка типов данных
5. ✅ Обнаружение смешивания полей (weaknesses/resourceSignals)

### После сохранения
1. ✅ Проверка ответа API
2. ✅ Логирование успешности операции
3. ✅ Возврат понятной ошибки при неудаче

## Рекомендации по использованию

1. **Мониторинг логов:** следите за префиксами `[SAL-GENERATION]` и `[CALC-SERVER]`
2. **Проверка валидации:** при ошибках валидации проверьте логи для деталей
3. **Retry при ошибках:** система автоматически повторяет попытки при серверных ошибках
4. **Fallback на n8n:** если серверная генерация не настроена, система использует n8n

## Производительность

- **Таймаут генерации:** 120 секунд
- **Таймаут сохранения:** 30 секунд
- **Кэширование промптов:** промпты загружаются один раз и кэшируются
- **Параллельная обработка:** поддержка множественных одновременных запросов

## Безопасность

- ✅ Валидация всех входных данных
- ✅ Проверка токенов перед запросами
- ✅ Обработка ошибок без раскрытия внутренних деталей
- ✅ Логирование без чувствительных данных

