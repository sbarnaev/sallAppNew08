import { NextRequest, NextResponse } from "next/server";
import { getDirectusUrl } from "@/lib/env";
import { ClientTestData, TestResult } from "@/lib/test-types";
import { logger } from "@/lib/logger";

/**
 * Получает токен для работы с Directus
 * Использует сервисный токен для публичных операций или токен из cookies для авторизованных
 */
function getDirectusToken(): string | null {
  // Сначала пытаемся использовать сервисный токен (для публичных операций)
  const serviceToken = process.env.DIRECTUS_SERVICE_TOKEN;
  if (serviceToken) {
    return serviceToken;
  }
  // Fallback - для разработки можно использовать обычный токен, но это не рекомендуется для production
  logger.warn("DIRECTUS_SERVICE_TOKEN not set, using fallback");
  return null;
}

export async function POST(req: NextRequest) {
  const baseUrl = getDirectusUrl();
  if (!baseUrl) {
    return NextResponse.json({ message: "No DIRECTUS_URL configured" }, { status: 500 });
  }

  const token = getDirectusToken();
  if (!token) {
    return NextResponse.json({ message: "Service token not configured" }, { status: 500 });
  }

  try {
    const body = await req.json();
    const { testToken, result, clientName, birthDate } = body; // НОВОЕ: clientName и birthDate

    if (!testToken || !result) {
      return NextResponse.json({ message: "testToken and result are required" }, { status: 400 });
    }

    // Валидация формата UUID
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(testToken)) {
      return NextResponse.json({ message: "Invalid token format" }, { status: 400 });
    }

    // Проверяем токен в test_tokens
    const tokenRes = await fetch(`${baseUrl}/items/test_tokens?filter[token][_eq]=${testToken}&fields=id,token,client_id,test_id,used,expires_at,request_birth_date`, {
      headers: { Authorization: `Bearer ${token}`, Accept: "application/json" },
      cache: "no-store"
    });

    if (!tokenRes.ok) {
      return NextResponse.json({ message: "Failed to verify token" }, { status: 500 });
    }

    const tokenData = await tokenRes.json().catch(() => ({ data: [] }));
    const tokenRecord = tokenData?.data?.[0];

    if (!tokenRecord) {
      return NextResponse.json({ message: "Invalid token" }, { status: 404 });
    }

    if (tokenRecord.used) {
      return NextResponse.json({ message: "Token already used" }, { status: 400 });
    }

    // Проверяем срок действия токена (если установлен)
    if (tokenRecord.expires_at) {
      const expiresAt = new Date(tokenRecord.expires_at);
      if (expiresAt < new Date()) {
        return NextResponse.json({ message: "Token expired" }, { status: 400 });
      }
    }

    const clientId = tokenRecord.client_id;
    const testId = tokenRecord.test_id;
    const requestBirthDate = Boolean(tokenRecord.request_birth_date);

    // НОВОЕ: Если запрошена дата рождения, данные обязательны
    if (requestBirthDate) {
      if (!clientName || !birthDate) {
        return NextResponse.json({ 
          message: "Имя и дата рождения обязательны для заполнения" 
        }, { status: 400 });
      }
      // Валидация даты рождения
      const birthDateObj = new Date(birthDate);
      if (isNaN(birthDateObj.getTime())) {
        return NextResponse.json({ message: "Invalid birth date format" }, { status: 400 });
      }

      // Проверяем, что дата не в будущем
      if (birthDateObj > new Date()) {
        return NextResponse.json({ message: "Birth date cannot be in the future" }, { status: 400 });
      }

      // Проверяем разумность даты (не старше 150 лет)
      const maxAge = new Date();
      maxAge.setFullYear(maxAge.getFullYear() - 150);
      if (birthDateObj < maxAge) {
        return NextResponse.json({ message: "Invalid birth date" }, { status: 400 });
      }

      // Форматируем дату в ISO формат (только дата, без времени)
      const formattedBirthDate = birthDate.split('T')[0]; // YYYY-MM-DD

      // Обновляем данные клиента
      const updateClientRes = await fetch(`${baseUrl}/items/clients/${clientId}`, {
        method: "PATCH",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({
          name: String(clientName).trim(),
          birth_date: formattedBirthDate
        })
      });

      if (!updateClientRes.ok) {
        const error = await updateClientRes.json().catch(() => ({}));
        logger.error("Failed to update client data:", error);
        return NextResponse.json({ message: "Failed to update client data", error }, { status: updateClientRes.status });
      }

      logger.log("Client data updated:", { clientId, name: clientName, birthDate: formattedBirthDate });
    } else if (requestBirthDate) {
      // Это не должно произойти из-за проверки выше, но на всякий случай
      return NextResponse.json({ 
        message: "Ошибка обновления данных клиента" 
      }, { status: 500 });
    }

    // Получаем текущие данные клиента
    const clientRes = await fetch(`${baseUrl}/items/clients/${clientId}?fields=id,testirovanie`, {
      headers: { Authorization: `Bearer ${token}`, Accept: "application/json" },
      cache: "no-store"
    });

    if (!clientRes.ok) {
      return NextResponse.json({ message: "Client not found" }, { status: 404 });
    }

    const clientData = await clientRes.json().catch(() => ({ data: {} }));
    let currentTestData: ClientTestData = {};
    
    // Обрабатываем testirovanie (может быть объектом или строкой JSON)
    const testirovanieRaw = clientData?.data?.testirovanie;
    if (testirovanieRaw) {
      if (typeof testirovanieRaw === "string") {
        try {
          currentTestData = JSON.parse(testirovanieRaw);
        } catch (e) {
          logger.warn("Failed to parse testirovanie JSON:", e);
          currentTestData = {};
        }
      } else if (typeof testirovanieRaw === "object") {
        currentTestData = testirovanieRaw;
      }
    }

    // Добавляем новый результат
    if (!currentTestData[testId]) {
      currentTestData[testId] = [];
    }
    currentTestData[testId].push(result as TestResult);

    // Обновляем клиента
    const updateRes = await fetch(`${baseUrl}/items/clients/${clientId}`, {
      method: "PATCH",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({ testirovanie: currentTestData })
    });

    if (!updateRes.ok) {
      const error = await updateRes.json().catch(() => ({}));
      logger.error("Failed to save test result:", error);
      return NextResponse.json({ message: "Failed to save result", error }, { status: updateRes.status });
    }

    // Помечаем токен как использованный
    const markUsedRes = await fetch(`${baseUrl}/items/test_tokens/${tokenRecord.id}`, {
      method: "PATCH",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({ used: true })
    });

    if (!markUsedRes.ok) {
      logger.warn("Failed to mark token as used, but result was saved");
    }

    return NextResponse.json({ success: true, data: currentTestData });
  } catch (error) {
    logger.error("Error submitting test result by token:", error);
    return NextResponse.json(
      { message: "Error submitting test result", error: String(error) },
      { status: 500 }
    );
  }
}
